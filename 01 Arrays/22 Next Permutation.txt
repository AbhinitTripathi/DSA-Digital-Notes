/*

- Array represents a permutation
- Next permutation will be the smallest permutation greater than current
- If I want to make the next greater number in maths, I look at the lest significatn digits

****OBSERVATION****
i)   In dictionary order the next elements tend to have the longest common prefix.
	e.g. abcda -> abcdb (abcd is same)
ii)  Since nos. after the breakpoint are in non increasing order we can fet the upper bound from back
iii) Elements after breakopint are bigger->smaller, if they were smaller->bigger, we would get lexicographically smallest

BRUTE: TC->O(2n! + n!log(n!)) SC->O(n!);
-> Generate all factorials and sort in increasing order
-> Search for current permutation then return the next one

void generatePermutations(vector<int>& nums, int index, vector<vector<int>>& result) {
    if (index == nums.size()) {
        result.push_back(nums);
        return;
    }
    for (int i = index; i < nums.size(); i++) {
        swap(nums[index], nums[i]);
        generatePermutations(nums, index + 1, result);
        swap(nums[index], nums[i]); // backtrack
    }
}

vector<int> nextPermutationBruteForce(vector<int>& nums) {
    vector<vector<int>> perms;

    // Generate all permutations recursively
    generatePermutations(nums, 0, perms);

    // Sort them in lexicographical order
    sort(perms.begin(), perms.end());

    // Find the current permutation
    for (int i = 0; i < perms.size(); i++) {
        if (perms[i] == nums) {
            // If it's the last, wrap to the first
            if (i == perms.size() - 1) return perms[0];
            else return perms[i + 1];
        }
    }

    // Should never reach here
    return nums;
}


OPTIMAL: TC->O(n) SC->O(1);
-> Find the number to be swapped **ind**, i.e. nums[i-1] < nums[i] then num at i-1;
-> Find the number to swap with, first greater element than nums[ind] from the right
-> Reverse everything after selected index

*/

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        int ind = -1;
        // Find Selected ind
        for(int i = n-1; i > 0; --i) {
            if(nums[i-1] < nums[i]) {
                ind = i-1;
                break;
            }
        }

        // If none select => last permutation i.e. descending order
        // Return asccentding
        // [4,3,2,1] -> [1,2,3,4]
        if(ind == -1) {
            reverse(nums.begin(), nums.end());
            return;
        }

        // find index to swap with
        // first greater element than nums[ind] from the right
        for(int j = n-1; j >= ind; --j) {
            if(nums[j] > nums[ind]) {
                swap(nums[j], nums[ind]);
                break;
            }
        }

        // reverse array from ind+1 till end
        reverse(nums.begin() + ind + 1, nums.end());
    }
};