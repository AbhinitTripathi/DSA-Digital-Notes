SEARCH IN ROTATED SORTED 1
/*

- All unique elements
- Array was first sorted then rotated
- FIND target in the given array

BRUTE: TC->O(n) SC->O(1)
-> Linear Search

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            if (nums[i] == target) return i;
        }
        return -1;
    }
};

OPTIMAL:
-> In a rotated sorted array One half (l -> m or m -> h) is always sorted
-> To apply BS we need to know which side (l -> m or m -> h) is sorted
    - if (a[l] < a[m]) => left sorted else right sorted

class Solution {
public:
    int search(vector<int>& arr, int k) {
        int n = arr.size();
        int l = 0, h = n - 1;

        while (l <= h) {
            int mid = (l + h) / 2;

            if (arr[mid] == k)
                return mid;

            if (arr[l] < arr[mid]) {
                if (arr[l] <= k && k <= arr[mid])
                    h = mid - 1;
                else
                    l = mid + 1;
            } else {
                if (arr[mid] <= k && k <= arr[h])
                    l = mid + 1;
                else
                    h = mid - 1;
            }
        }

        return -1;
    }
};
*/


SEARCH IN ROTATED SORTED 2
class Solution {
public:
    int search(vector<int>& arr, int k) {
        int n = arr.size();
        int l = 0, h = n - 1;

        while (l <= h) {
            int mid = (l + h) / 2;

            while (l < h && arr[l] == arr[mid] && arr[mid] == arr[h]) {
                l++;
                h--;
            }

            if (arr[mid] == k)
                return true;

            if (arr[l] <= arr[mid]) {
                if (arr[l] <= k && k <= arr[mid])
                    h = mid - 1;
                else
                    l = mid + 1;
            } else {
                if (arr[mid] <= k && k <= arr[h])
                    l = mid + 1;
                else
                    h = mid - 1;
            }
        }

        return false;
    }
};