/*

BRUTE: TC->O(2n) SC->O(n)
-> Use a hash map to figure out which element has count 1

class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        unordered_map<int, int> mp;
        for (int num : nums) mp[num]++;

        // Iterate in map to find single element
        for (auto &[num, freq] : mp) {
            if (freq == 1) return num;
        }

        return -1;
    }
};

BETTER: TC->O(n) SC->O(1)
-> XOR the entire array, same numbers will become 0 leaving the unique one

class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int ans = 0;
        for (int num : nums) ans ^= num;
        return ans;
    }
};

OPTIMAL:
-> Do a Binary Search
-> Use parity of pairs to identify unique el is on right of mid or left of mid
    [. . . . . . x . .]
     0 1 2 3 4 5 6 7 8
     E O E O E O E O E

class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int n = nums.size();

        if (n == 1) return nums[0];
        if (nums[0] != nums[1]) return nums[0];
        if (nums[n-2] != nums[n-1]) return nums[n-1];
        
        int l = 1, h = n-2;
        while (l <= h) {
            int m = (l + h) / 2;

            // Am I on x
            if (nums[m-1] != nums[m] && nums[m] != nums[m+1])
                return nums[m];

            // Am I standing on the left of x?
            if ( (m % 2 == 1 && nums[m] == nums[m-1]) || (m % 2 == 0 && nums[m] == nums[m+1]) ) {
                l = m + 1;
            } else {
                h = m - 1;
            }
        }

        return -1;
    }
};
*/