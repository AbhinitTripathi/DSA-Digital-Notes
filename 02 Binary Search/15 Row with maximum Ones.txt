/*
- We have a matrix
- Each row is sorted in non-decreasing order
    - Repeating elements
    - All ones appear together & they come after zeroes
- We need the index of a row that has maximum ones
- If no such row exists return -1
    - Only possible when matrix has all zeroes
        - We can check the last element of each row
          since array is sorted it will have a 1 if any

BRUTE: TC ~ O(n^2) | SC ~ O(1)
- Traverse in the matrix and count number of 1 for every row

int rowWithMaxOnes_Brute(vector<vector<int>>& mat) {
    int n = mat.size(), m = mat[0].size();
    int maxOnes = 0, ans = -1;

    for (int i = 0; i < n; i++) {
        int count = 0;
        for (int j = 0; j < m; j++) {
            if (mat[i][j] == 1) count++;
        }
        if (count > maxOnes) {
            maxOnes = count;
            ans = i;
        }
    }
    return ans;
}

BETTER: TC ~ O(nlogm) | SC ~ O(1)
- If we can find the 1st occurance of 1 say at index i,
  then number of ones can be m - i;
    - 1st one = first element taht is greater than 0
        - upper_bound(0);

int rowWithMaxOnes_Better(vector<vector<int>>& mat) {
    int n = mat.size(), m = mat[0].size();
    int maxOnes = 0, ans = -1;

    for (int i = 0; i < n; i++) {
        // Find the first index of 1
        int idx = lower_bound(mat[i].begin(), mat[i].end(), 1) - mat[i].begin();

        if (idx < m) {
            int ones = m - idx;
            if (ones > maxOnes) {
                maxOnes = ones;
                ans = i;
            }
        }
    }
    return ans;
}

OPTIMAL:
- Start at top-right corner.
- While inside the matrix:
    - If current cell = 1 → move left (maybe more 1s).
      Update row index.
    - If current cell = 0 → move down
      (this row can’t have more 1s than already seen).
- The last updated row index = row with maximum 1s.
- If no 1s found → return -1.

int rowWithMaxOnes_Optimal(vector<vector<int>>& mat) {
    int n = mat.size(), m = mat[0].size();
    int ans = -1;
    int j = m - 1;  // start from top-right corner

    for (int i = 0; i < n; i++) {
        while (j >= 0 && mat[i][j] == 1) {
            ans = i;   // update row index
            j--;       // move left since more 1s may exist
        }
    }
    return ans;
}
*/
class Solution {
  public:
    int rowWithMax1s(vector<vector<int>> &mat) {
        int n = mat.size(), m = mat[0].size();
        int ans = -1;
        int j = m - 1;  // start from top-right corner
        
        for (int i = 0; i < n; i++) {
            while (j >= 0 && mat[i][j] == 1) {
                ans = i;   // update row index
                j--;       // move left since more 1s may exist
            }
        }
        return ans;
    }
};