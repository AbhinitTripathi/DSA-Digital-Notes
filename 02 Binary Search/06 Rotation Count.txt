/*

- Sorted in Ascending order
- Distinct elements
- The array is right rotated
- Find how many times the array has been rotated

a[i-1] < a[i] > a[i+1] | i is the pivot index or the infliction point

BRUTE: TC->O(n) SC->O(1)
-> For every element check if curr_el > next_el
    IF yes then
        return i + 1;
    ELSE
        continue;
-> return 0 at the end showing that the array is not rotated at all

int findKRotation(vector<int> &arr) {
    int n = arr.size();
    for (int i = 0; i < n-1; ++i) {
        if (arr[i] > arr[i+1])
            return i+1;
    }
    return 0;
}

OPTIMAL: TC->O(logn) SC->O(1)
-> Find index of the minimum element
-> return it

int findKRotation(vector<int> &arr) {
    int n = arr.size();
    int l = 0, h = n-1;

    int ans = 0;
    int min_el = 1e9;
    while (l <= h) {
        int m = (l + h) / 2;

        if (arr[l] < arr[h]) {
            if (arr[l] < min_el)
                return l;
        }

        if (arr[l] <= arr[m]) {

            if (arr[l] < min_el) {
                ans = l;
                min_el = arr[l];
            }
            l = m + 1;

        } else if (arr[m] <= arr[h]) {

            if (arr[m] < min_el) {
                ans = m;
                min_el = arr[m];
            }
            h = m - 1;

        }

    }

    return ans;
}
*/
