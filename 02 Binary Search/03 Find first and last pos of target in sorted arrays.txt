/*

BRUTE: TC->O(n) SC->O(1)
-> Linear Search to find the first & last position
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> res = {-1, -1}
        for (int i = 0; i < n; ++i) {
            if (nums[i] != target) continue;
            res[0] = i;
            while (nums[i] == target) i++;
            res[1] = i-1
        }
        return res;
    }
};


OPTMAL: TC->O(2logn) SC->O(1);
class Solution {
public:
  vector<int> searchRange(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> ans;
    int low = 0, high = n - 1;

    // Lower Bound
    int lowerBound = -1;
    while(low <= high) {
      int mid = low+(high-low)/2;
      if(nums[mid] == k) {
        lowerBound = mid;
        high = mid - 1;
      } else if(nums[mid] < k) low = mid + 1;
      else high = high - 1;
    }

    low  = 0;
    high = n-1;
    
    // Upper Bound
    int upperBound = -1;
    while(low <= high) {
      int mid = low+(high-low)/2;
      if(nums[mid] == k){
        upperBound = mid;
        low = mid+1;
      } else if(nums[mid] < k) low = mid+1;
      else high = high-1;
    }

    ans.push_back(lowerBound);
    ans.push_back(upperBound);

    return ans;
  }
};
*/