/*

- Array elements are >= 0
- Not sorted
- Length of the longest subarray whose sum == k

BRUTE: TC-> O(n^3) SC-> O(1)
-> Generate all subarrays
-> Check every subarray if it meets condition of not

int longestSubarrayWithSumK(vector<int> a, long long k) {
    int n = a.size();
    int maxLen = -1e9;
    for(int s = 0; s < n; ++s) {
        for(int e = s; e < m; ++e) {
            long long sum = 0;
            for(int i =  s; i <= e; ++i) sum += a[i];
            if(sum == k) {
                int subLen = e-s+1;
                maxLen = max(maxLen, subLen);
            }
        }
    }

    return maxLen;
}

BETTER 1: TC-> O(n^2) SC-> O(1)
-> Generate all subarrays;
-> Find sum while generating
    sum of nuw subarray = a[e] + sum of old subarray

int longestSubarrayWithSumK(vector<int> a, long long k) {
    int n = a.size();
    int maxLen = -1e9;
    for(int s = 0; s < n; ++s) {
        long long sum = 0;
        for(int e = s; e < m; ++e) {
            sum += a[e]
            if(sum == k) maxLen = max(maxLen, e-s+1);
            if(sum >= k) break;
        }
    }

    return maxLen;
}

BETTER 2: TC-> O(n) SC-> O(n)
-> use prefixSum + HashMap (sum -> earliest inedx (for longest subarray))
-> INTUITION
    - if till index i the sum is  x,
    - Assume there is a subarray ending at index i with sum k
    - then the remaining sum has to be x - k, if it exists then subarray with sum k exists

    . . . . . . . . .
    <--x-k===><--k-->
    <-------x------->

-> keep a hashMap with 0 -> -1 (empty subarray has a sum of 0)

int longestSubarrayWithSumK(vector<int> a, long long k) {
    int n = a.size();
    unordered_map<int,int> mp;
    int sum = 0, maxLen = 0;

    // Populate hashMap
    mp[0] = -1;
    for(int i; i < n; ++i) {
        int el = a[i];
        sum += el;
        if(mp.find(sum) == mp.end()) mp[sum] = i; // store only if sum is not already present
                                                    (earliest index give largst subarray)
    }

    sum = 0;
    for(int e = 0; e < n; ++e) {
        sum += a[e];
        if(mp.find(sum - k) != mp.end()) {
            int s = mp[sum-k] + 1;
            maxLen = max(maxLen, e-s+1);
        }
    }

    return maxLen;
}

OPTIMAL: TC-> O(n) SC-> O(1)
- Have a sliding window
- when sum > k reduce window
- when sum == k update length
- whien sum <= k increase window

int longestSubarrayWithSumK(vector<int> a, long long k) {
    int left = 0, right = 0, maxLen = 0;
    long long sum = a[0];

    int n = a.size();
    while(right < n) {
        while(left <= right && sum > k) {
            sum -= a[left];
            left++;
        }

        if(sum <= k) {
            maxLen = max(maxLen, right-left+1);
        }

        right++;
        if(right < n) sum += a[right];
    }
    return maxLen;
}
*/



int longestSubarrayWithSumK(vector<int> a, long long k) {
    int left = 0, right = 0, maxLen = 0;
    long long sum = a[0];

    int n = a.size();
    while(right < n) {
        while(left <= right && sum > k) {
            sum -= a[left];
            left++;
        }

        if(sum <= k) {
            maxLen = max(maxLen, right-left+1);
        }

        right++;
        if(right < n) sum += a[right];
    }
    return maxLen;
}