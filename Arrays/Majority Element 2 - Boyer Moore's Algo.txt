/*
BRUTE: TC->O(n^2) SC->O(n)
-> check frequeny of each element if it is greater than el1 or el2 update it;

class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int n = nums.size();
        int el1 = INT_MIN, el2 = INT_MIN;
        int max1 = INT_MIN, max2 = INT_MIN;

        for (int i = 0; i < n; i++) {
            if(nums[i] == el1 || nums[i] == el2) continue;
            
            int freq = 0;
            for (int j = 0; j < n; j++) {
                if (nums[i] == nums[j]) {
                    freq++;
                }
            }
            if (freq > max1) {
                max2 = max1;
                el2 = el1;
                max1 = freq;
                el1 = nums[i];
            }
            else if (freq > max2) {
                max2 = freq;
                el2 = nums[i];
            }
        }

        vector<int> result;
        if(el1 == el2) {
            if (max1 > n / 3) result.push_back(el1);
            return result;    
        }
        if (max1 > n / 3) result.push_back(el1);
        if (max2 > n / 3) result.push_back(el2);

        return result;
    }
};


BETTER: TC->O(n) SC->O(n);
-> Same idea as brute but using hash map

class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        unordered_map<int, int> freq;

        // Count frequencies
        for (int el : nums) {
            freq[el]++;
        }

        vector<int> res;
        int threshold = nums.size() / 3;

        // Collect elements that appear more than n/3 times
        for (auto& p : freq) {
            if (p.second > threshold) {
                res.push_back(p.first);
            }
        }

        return res;
    }
};


OPTIMAL: TC->O(N) SC->O(N)
-> Moore's Voting Algo with 2 candidates

class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        // Moore's Algo for 2 candidates (Boyer Morre's Also)
        vector<int> ans;
        int cand1 = INT_MIN, vote1 = 0;
        int cand2 = INT_MIN, vote2 = 0;
        int n     = nums.size();

        for(int i = 0; i < n; i++) {
            if(vote1 == 0 && cand2 != nums[i]) {
                vote1 = 1;
                cand1 = nums[i];
            } else if(vote2 == 0 && cand1 != nums[i]) {
                vote2 = 1;
                cand2 = nums[i];
            } 
            else if(nums[i] == cand1) vote1++;
            else if(nums[i] == cand2) vote2++;
            else {
                vote1--; vote2--;
            }
        }

        vote1 = 0; vote2 = 0;
        int min = (int)(n/3);
        for(auto &i : nums) {
            if(i == cand1) vote1++;
            if(i == cand2) vote2++;
        }

        if(vote1 > min) ans.push_back(cand1);
        if(vote2 > min) ans.push_back(cand2);
        return ans;
    }
};

*/
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        
    }
};