as n becomes > 4800 the value of the result becomes very close to 1
e.g. for 4801 the ans is 1.00000_ _ _ _, ans goes so close to one that from 4800 is basically becomes 1

-------------------------------------- MEMOIZATION --------------------------------------
class Solution {
private:
    pair<int,int> servings[4] = {{100,0}, {75,25}, {50,50}, {25,75}};
    double calculateAProb(int a, int b, vector<vector<double>>& dp) {
        if(a == 0 && b != 0) return 1.0;
        if(a == 0 && b == 0) return 0.5;
        if(b == 0) return 0;

        if(dp[a][b] != -1) return dp[a][b];

        double serving_sum = 0;
        for(auto &serving : servings) {
            int new_a = (a <= serving.first) ? 0 : a-serving.first;
            int new_b = (b <= serving.second) ? 0 : b-serving.second;

            serving_sum += calculateAProb(new_a, new_b, dp) * 0.25;
        }

        return dp[a][b] = serving_sum;
    }
public:
    double soupServings(int n) {
        if(n >= 4800) return 1.0;
        
        vector<vector<double>> dp(n+1, vector<double>(n+1, -1));
        return calculateAProb(n, n, dp);
    }
};

-------------------------------------- TABULATION --------------------------------------
class Solution {
private:
    pair<int,int> servings[4] = {{100,0}, {75,25}, {50,50}, {25,75}};
    double calculateAProb(int a, int b, vector<vector<double>>& dp) {
        if(a == 0 && b != 0) return 1.0;
        if(a == 0 && b == 0) return 0.5;
        if(b == 0) return 0;

        if(dp[a][b] != -1) return dp[a][b];

        double serving_sum = 0;
        for(auto &serving : servings) {
            int new_a = (a <= serving.first) ? 0 : a-serving.first;
            int new_b = (b <= serving.second) ? 0 : b-serving.second;

            serving_sum += calculateAProb(new_a, new_b, dp) * 0.25;
        }

        return dp[a][b] = serving_sum;
    }
public:
    double soupServings(int n) {
        if(n >= 4800) return 1.0;
        vector<vector<double>> dp(n+1, vector<double>(n+1, 0.0));

        dp[0][0] = 0.5;
        for(int i = 1; i <= n; ++i) dp[0][i] = 1.0;

        for(int a = 1; a <= n; ++a) {
            for(int b = 1; b <= n; ++b) {
                for(auto &serving : servings) {
                    int new_a = (a <= serving.first) ? 0 : a-serving.first;
                    int new_b = (b <= serving.second) ? 0 : b-serving.second;

                    dp[a][b] += dp[new_a][new_b] * 0.25;
                }
            }
        }

        return dp[n][n];
    }
};

******* SPACE IS VERY TRICKY AND COMPLICATED TO OPTIMIZE HERE AS WE NEED 4 DIFFERENT STATES FOR EACH A AND B *******