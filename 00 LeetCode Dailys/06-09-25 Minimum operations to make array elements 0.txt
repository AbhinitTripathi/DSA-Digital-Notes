class Solution {
private:
    typedef long long ll;

    // Stores tuples of the form (L, R, steps):
    // - L = starting value of the block
    // - R = ending value of the block
    // - steps = number of divisions by 4 (floor(log4(x)) + 1) for any x in [L, R]
    //
    // Example:
    // [1, 3]   -> steps = 1
    // [4, 15]  -> steps = 2
    // [16, 63] -> steps = 3
    // ...
    vector<tuple<ll, ll, ll>> range_operations;

    // Given a query [l, r], compute total operations:
    // - For each block [L, R] intersecting [l, r],
    //   add (#elements_in_intersection * steps).
    // - Each loop iteration in the original process handles up to 2 numbers,
    //   so answer = ceil(total_operations / 2).
    ll operations_count_in_range(int l, int r) {
        ll total_operations = 0;
        for (auto &[L, R, steps] : range_operations) {
            if (L > r) break; // no overlap possible beyond this block

            ll in_range_l = max(L, (ll)l);
            ll in_range_r = min(R, (ll)r);
            if (in_range_l > in_range_r) continue; // no overlap

            ll elements_in_range = in_range_r - in_range_l + 1;
            total_operations += elements_in_range * steps;
        }

        // Each iteration can process 2 numbers, so we need ceil(total/2).
        // Using integer math: ceil(a/b) = (a + b - 1) / b
        return (total_operations + 1) / 2;
    }

public:
    long long minOperations(vector<vector<int>>& queries) {
        // Precompute all block ranges up to 1e9.
        // At most ~15 blocks are needed because 4^15 > 1e9.
        if (range_operations.empty()) {
            for (int i = 0; i <= 15; ++i) {
                ll L = 1LL << (2 * i);              // L = 4^i
                ll R = (1LL << (2 * (i + 1))) - 1;  // R = 4^(i+1) - 1
                ll steps = i + 1;                   // floor(log4(x)) + 1
                range_operations.push_back({L, R, steps});
            }
        }

        ll res = 0;
        for (auto &query : queries) {
            int l = query[0], r = query[1];
            res += operations_count_in_range(l, r);
        }
        return res;
    }
};
